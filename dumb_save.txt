def compute_fuzzy_out(fuzzy_weights, input_variables, neurons, rules):
    fuzzy_weights_r = einops.repeat(fuzzy_weights, "neurons rules variables -> neurons rules variables")
    input_variables_r = einops.repeat(input_variables, "variables -> neurons rules variables", neurons=neurons, rules=rules)
    updated_variables : Float[Tensor, "neuron rules variables"] = 1 - fuzzy_weights_r * (1 - input_variables_r)
    # fuzzy_mid = einops.reduce(updated_variables, "pos neurons rules variables -> pos neurons rules", "min")  # AND Gate
    # fuzzy_out = einops.reduce(fuzzy_mid, "pos neurons rules -> pos neurons", "max")  # OR Gate
    updated_variables = updated_variables.min(dim=-1).values  # AND Gate
    updated_variables = updated_variables.max(dim=-1).values  # OR Gate
    return updated_variables

def compute_fuzzy_mid(fuzzy_weights, input_variables, v, batch, neurons, rules):
    return 1 - einops.repeat(fuzzy_weights[:, :, v], "neurons rules -> batch neurons rules", batch=batch) * (1 - einops.repeat(input_variables[:, :, v], "batch -> batch neurons rules", neurons=neurons, rules=rules))

def compute_fuzzy_out_new(fuzzy_weights, input_variables):
    neurons, rules, variables = fuzzy_weights.shape
    batch, variables = input_variables.shape
    # fuzzy_weights_r = einops.repeat(fuzzy_weights, "neurons rules variables -> pos neurons rules variables")
    # input_variables_r = einops.repeat(input_variables, "batch pos variables -> pos neurons rules variables")
    fuzzy_mid = t.zeros((batch, neurons, rules)).to(device)
    for v in range(variables):
        if debug:
            print(f"Fuzzy Logic started for variable {v}")
            debug_memory()
        fuzzy_mid = t.min(fuzzy_mid, compute_fuzzy_mid(fuzzy_weights, input_variables, v, batch, neurons, rules))
    # fuzzy_mid = einops.reduce(updated_variables, "pos neurons rules variables -> pos neurons rules", "min")  # AND Gate
    # fuzzy_out = einops.reduce(fuzzy_mid, "pos neurons rules -> pos neurons", "max")  # OR Gate
    updated_variables = updated_variables.min(dim=-1).values  # AND Gate
    updated_variables = updated_variables.max(dim=-1).values  # OR Gate
    return updated_variables

def perform_fuzzy_logic(args : FuzzyTrainingArgs, input_variables : Float[Tensor, "batch variables"], fuzzy_weights : Float[Tensor, "neuron rules variables"], rule_weights : Float[Tensor, "rules"]) -> Dict[str, Tuple]:
    batch, variables = input_variables.shape
    neurons, rules, _ = fuzzy_weights.shape
    if neurons == 1:
        fuzzy_weights_r = einops.repeat(fuzzy_weights, "neurons rules variables -> batch neurons rules variables", batch=batch)
        input_variables_r = einops.repeat(input_variables, "batch variables -> batch neurons rules variables", neurons=neurons, rules=rules)
        updated_variables : Float[Tensor, "batch neuron rules variables"] = 1 - fuzzy_weights_r * (1 - input_variables_r)
        if args.fuzzy_and == "mul":
            fuzzy_mid = updated_variables.prod(dim=-1) * rule_weights.sigmoid() # AND Gate
        else:
            fuzzy_mid = einops.reduce(updated_variables, "batch neurons rules variables -> batch neurons rules", "min")  # AND Gate
        if args.rules_count == 1:
            fuzzy_out = fuzzy_mid.squeeze(dim=-1)
        if args.learn_rules:
            fuzzy_mid_sum = 1 - fuzzy_mid.sum(dim=-1)
            rule_0 : Float[Tensor, "batch neurons"] = t.max(t.zeros_like(fuzzy_mid_sum).to(device), fuzzy_mid_sum).unsqueeze(dim=-1)
            fuzzy_out = t.cat([rule_0, fuzzy_mid], dim=-1)
            return fuzzy_out
        else:
            if args.fuzzy_or == "max":
                fuzzy_out = einops.reduce(fuzzy_mid, "batch neurons rules -> batch neurons", "max") # OR Gate
            elif args.fuzzy_or == "prob_sum":
                fuzzy_out = 1 - (1 - fuzzy_mid).prod(dim=-1) #OR Gate
        return fuzzy_out
    fuzzy_out_complete = []
    for b in range(batch):
        if debug:
            print(f"Fuzzy Logic started for batch {b}")
            debug_memory()
        fuzzy_out = compute_fuzzy_out(fuzzy_weights, input_variables[b], neurons, rules)
        fuzzy_out_complete.append(fuzzy_out)
    fuzzy_out_complete = t.stack(fuzzy_out_complete, dim=0)
    # fuzzy_out_complete = compute_fuzzy_out_new(fuzzy_weights, input_variables)
    return fuzzy_out_complete